# -*- coding: utf-8 -*-
"""EVIDENCIA A00839234

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ll8WaJfqRwmHtv5h97Sr4mTEpXOzZXoL
"""

# -*- coding: utf-8 -*-
"""EVIDENCIA A00839234

This script analyzes a portfolio of stocks (XOM, PG, AAPL, PFE) from HowTheMarketWorks
using time series modeling, stationarity tests, cointegration analysis, forecasting,
and portfolio performance evaluation as part of the "Automation of Algorithms in
Capital Analyst Portfolios" project.

Automatically generated by Colab.
Original file is located at
    https://colab.research.google.com/drive/1ll8WaJfqRwmHtv5h97Sr4mTEpXOzZXoL
"""

import yfinance as yf
import pandas as pd
from statsmodels.tsa.stattools import adfuller, coint
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import numpy as np

# Ensure plots are displayed inline (commented for .py compatibility, use in Colab)
# %matplotlib inline

def download_and_clean_data(tickers, start_date, end_date):
    """Download historical stock data and calculate daily returns.

    Args:
        tickers (list): List of stock tickers.
        start_date (str): Start date for data (YYYY-MM-DD).
        end_date (str): End date for data (YYYY-MM-DD).

    Returns:
        pandas.DataFrame: DataFrame of daily returns.
    """
    try:
        data = yf.download(tickers, start=start_date, end=end_date)['Close']
        returns = data.pct_change().dropna()
        returns.to_csv('portfolio_returns.csv')
        return returns
    except Exception as e:
        print(f"Error downloading data: {e}")
        raise

# Define the tickers from your HowTheMarketWorks portfolio
tickers = ['XOM', 'PG', 'AAPL', 'PFE']

# Download historical data (2 years up to June 14, 2025, current date)
returns = download_and_clean_data(tickers, start_date='2023-06-14', end_date='2025-06-14')

# Display the first few rows and summary statistics
print("Cleaned Returns Data:")
print(returns.head())
print("\nSummary Statistics:")
print(returns.describe())

def adf_test(series, stock_name):
    """Perform Augmented Dickey-Fuller test for stationarity.

    Args:
        series (pandas.Series): Time series to test.
        stock_name (str): Name of the stock.
    """
    result = adfuller(series)
    print(f"\nADF Test Results for {stock_name}:")
    print(f"ADF Statistic: {result[0]:.2f}")
    print(f"p-value: {result[1]:.4f}")
    print("Critical Values:", {k: v for k, v in result[4].items()})
    if result[1] < 0.05:
        print("Conclusion: Reject H0 - Series is stationary.")
    else:
        print("Conclusion: Fail to reject H0 - Series is non-stationary.")

# Apply ADF test to each stock's returns
for ticker in tickers:
    adf_test(returns[ticker], ticker)

def fit_arima(series, stock_name, order=(1, 0, 1)):
    """Fit an ARIMA model to the time series.

    Args:
        series (pandas.Series): Time series to model.
        stock_name (str): Name of the stock.
        order (tuple): ARIMA order (p, d, q).

    Returns:
        statsmodels.tsa.arima.model.ARIMAResults: Fitted model results.
    """
    try:
        model = ARIMA(series, order=order)
        model_fit = model.fit()
        print(f"\nARIMA({order[0]},{order[1]},{order[2]}) Summary for {stock_name}:")
        print(model_fit.summary())
        return model_fit
    except Exception as e:
        print(f"Error fitting ARIMA for {stock_name}: {e}")
        raise

# Fit ARIMA models using best orders
models = {}
for ticker in tickers:
    models[ticker] = fit_arima(returns[ticker], ticker, order=best_orders[ticker])

# Plot residuals for one stock (e.g., XOM) to check model fit
residuals = models['XOM'].resid
plt.figure(figsize=(10, 6))
plt.plot(residuals)
plt.title('Residuals of ARIMA(1,0,1) for XOM')
plt.show()

# Fetch original data for cointegration (assuming data is still in scope)
data = yf.download(tickers, start='2023-06-14', end='2025-06-14')['Close']

# Test cointegration between pairs
pairs = [('XOM', 'PG'), ('AAPL', 'PFE')]
for stock1, stock2 in pairs:
    score, p_value, _ = coint(data[stock1], data[stock2])
    print(f"\nCointegration Test between {stock1} and {stock2}:")
    print(f"p-value: {p_value:.4f}")
    if p_value < 0.05:
        print("Conclusion: Reject H0 - Cointegration exists.")
    else:
        print("Conclusion: Fail to reject H0 - No cointegration.")

def forecast_and_plot(model, stock_name, steps):
    """Generate and plot forecasts for a given stock.

    Args:
        model (statsmodels.tsa.arima.model.ARIMAResults): Fitted ARIMA model.
        stock_name (str): Name of the stock.
        steps (int): Number of forecast steps.

    Returns:
        pandas.Series: Forecast values.
    """
    try:
        forecast = model.forecast(steps=steps)
        plt.figure(figsize=(10, 6))
        plt.plot(forecast, label='Forecast')
        plt.plot(returns[stock_name][-steps:], label='Actual', color='red')
        plt.title(f'{steps}-Day Forecast for {stock_name}')
        plt.legend()
        plt.show()
        return forecast
    except Exception as e:
        print(f"Error forecasting for {stock_name}: {e}")
        raise

def forecast_and_plot(model, stock_name, steps, actual_series):
    """Generate and plot forecasts for a given stock, and calculate deviations.

    Args:
        model (statsmodels.tsa.arima.model.ARIMAResults): Fitted ARIMA model.
        stock_name (str): Name of the stock.
        steps (int): Number of forecast steps.
        actual_series (pandas.Series): Actual series for comparison.

    Returns:
        pandas.Series: Forecast values.
    """
    try:
        forecast = model.forecast(steps=steps)
        # Get the last 'steps' actual values for comparison
        actual = actual_series[-steps:]
        # Calculate percentage deviation
        deviation = abs((forecast - actual) / actual) * 100
        print(f"\nDeviation for {stock_name} (Percentage):")
        print(deviation)
        if (deviation > 10).any():
            print(f"Warning: {stock_name} forecast deviates >10%. Possible reasons: high volatility or model misspecification.")
        else:
            print(f"{stock_name} forecast is within 10% of actual values.")
        # Plot forecast vs actual
        plt.figure(figsize=(10, 6))
        plt.plot(forecast.index, forecast.values, label='Forecast', color='blue')
        plt.plot(actual.index, actual.values, label='Actual', color='red')
        plt.title(f'{steps}-Day Forecast vs Actual for {stock_name}')
        plt.legend()
        plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
        plt.gca().xaxis.set_major_locator(mdates.DayLocator())
        plt.gcf().autofmt_xdate()
        plt.savefig(f'forecast_{stock_name}.png')  # Save plot for report
        plt.show()
        return forecast
    except Exception as e:
        print(f"Error forecasting for {stock_name}: {e}")
        raise

# Generate 10-day forecasts for each stock
steps = 10
forecasts = {}
for ticker in tickers:
    forecasts[ticker] = forecast_and_plot(models[ticker], ticker, steps, returns[ticker])

# Print forecast values
print("\nForecasts (10 Days):")
for ticker, forecast in forecasts.items():
    print(f"{ticker}: {forecast.values}")
# Define portfolio weights based on HowTheMarketWorks allocation
weights = {'XOM': 0.2607, 'PG': 0.2635, 'AAPL': 0.2478, 'PFE': 0.2279}

# Calculate portfolio returns
portfolio_returns = sum(weights[ticker] * returns[ticker] for ticker in tickers)

# Cumulative portfolio returns
cumulative_returns = (1 + portfolio_returns).cumprod()

# Plot cumulative returns
plt.figure(figsize=(10, 6))
plt.plot(cumulative_returns.index, cumulative_returns.values)
plt.title('Cumulative Portfolio Returns')
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
plt.gca().xaxis.set_major_locator(mdates.MonthLocator())
plt.gcf().autofmt_xdate()
plt.show()

# Summary statistics
print("\nPortfolio Return Statistics:")
print(portfolio_returns.describe())

# Simple strategy: Buy if forecast > 0, Sell if < 0
signals = {ticker: (forecasts[ticker] > 0).astype(int) for ticker in tickers}
strategy_returns = {ticker: signals[ticker].shift(1) * returns[ticker] for ticker in tickers}

# Portfolio strategy returns
portfolio_strategy_returns = sum(weights[ticker] * strategy_returns[ticker] for ticker in tickers)

# Cumulative strategy returns
cumulative_strategy_returns = (1 + portfolio_strategy_returns).cumprod()

# Align indices: Reindex cumulative_strategy_returns to match cumulative_returns' DatetimeIndex
cumulative_strategy_returns = cumulative_strategy_returns.reindex(cumulative_returns.index).fillna(0)

# Plot strategy vs passive returns
plt.figure(figsize=(10, 6))
plt.plot(cumulative_returns.index, cumulative_returns.values, label='Passive Returns', color='red')
plt.plot(cumulative_strategy_returns.index, cumulative_strategy_returns.values, label='Strategy Returns')
plt.title('Cumulative Returns: Strategy vs Passive')
plt.legend()
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
plt.gca().xaxis.set_major_locator(mdates.MonthLocator())
plt.gcf().autofmt_xdate()
plt.show()

# Debug print to verify data
print("Reindexed Cumulative Strategy Returns Head:")
print(cumulative_strategy_returns.head())
print("Cumulative Returns Head:")
print(cumulative_returns.head())

from statsmodels.stats.diagnostic import acorr_ljungbox
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# Residual diagnostics for all stocks
for ticker in tickers:
    print(f"\nResidual Diagnostics for {ticker}:")
    residuals = models[ticker].resid
    # Ljung-Box test for white noise (lag=10)
    lb_test = acorr_ljungbox(residuals, lags=[10], return_df=True)
    print(f"Ljung-Box Test (lag=10): p-value = {lb_test['lb_pvalue'].iloc[0]:.4f}")
    if lb_test['lb_pvalue'].iloc[0] > 0.05:
        print("Conclusion: Residuals are white noise (no significant autocorrelation).")
    else:
        print("Conclusion: Residuals show autocorrelation (model may need adjustment).")
    # ACF and PACF plots
    plt.figure(figsize=(10, 4))
    plt.subplot(121)
    plot_acf(residuals, lags=20, ax=plt.gca())
    plt.title(f'ACF of Residuals ({ticker})')
    plt.subplot(122)
    plot_pacf(residuals, lags=20, ax=plt.gca())
    plt.title(f'PACF of Residuals ({ticker})')
    plt.tight_layout()
    plt.savefig(f'residuals_{ticker}.png')  # Save plot for report
    plt.show()

# Calculate risk metrics (annualized)
mean_returns = returns.mean() * 252  # Annualized mean returns (252 trading days)
std_dev = returns.std() * np.sqrt(252)  # Annualized standard deviation
sharpe_ratio = mean_returns / std_dev  # Sharpe ratio (assuming risk-free rate = 0 for simplicity)

# Portfolio risk metrics
portfolio_mean = portfolio_returns.mean() * 252
portfolio_std = portfolio_returns.std() * np.sqrt(252)
portfolio_sharpe = portfolio_mean / portfolio_std

# Print risk metrics
print("\nIndividual Stock Risk Metrics (Annualized):")
for ticker in tickers:
    print(f"{ticker} - Mean Return: {mean_returns[ticker]:.4f}, Std Dev: {std_dev[ticker]:.4f}, Sharpe Ratio: {sharpe_ratio[ticker]:.4f}")
print(f"\nPortfolio Risk Metrics (Annualized):")
print(f"Mean Return: {portfolio_mean:.4f}, Std Dev: {portfolio_std:.4f}, Sharpe Ratio: {portfolio_sharpe:.4f}")

# Plot risk metrics for visualization
plt.figure(figsize=(10, 6))
plt.bar(tickers + ['Portfolio'], list(sharpe_ratio.values) + [portfolio_sharpe], color=['blue', 'blue', 'blue', 'blue', 'green'])
plt.title('Sharpe Ratios for Stocks and Portfolio')
plt.ylabel('Sharpe Ratio')
plt.savefig('sharpe_ratios.png')  # Save plot for report
plt.show()

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from itertools import product

def select_arima_order(series, stock_name, max_p=2, max_d=1, max_q=2):
    """Select best ARIMA order based on AIC.

    Args:
        series (pandas.Series): Time series to model.
        stock_name (str): Name of the stock.
        max_p (int): Maximum AR order.
        max_d (int): Maximum differencing order.
        max_q (int): Maximum MA order.

    Returns:
        tuple: Best (p, d, q) order.
    """
    print(f"\nSelecting ARIMA Order for {stock_name}:")
    # Plot ACF/PACF to guide order selection
    plt.figure(figsize=(10, 4))
    plt.subplot(121)
    plot_acf(series, lags=20, ax=plt.gca())
    plt.title(f'ACF for {stock_name} Returns')
    plt.subplot(122)
    plot_pacf(series, lags=20, ax=plt.gca())
    plt.title(f'PACF for {stock_name} Returns')
    plt.tight_layout()
    plt.savefig(f'acf_pacf_{stock_name}.png')  # Save plot for report
    plt.show()

    # Try different ARIMA orders
    p = range(0, max_p + 1)
    d = range(0, max_d + 1)
    q = range(0, max_q + 1)
    pdq = list(product(p, d, q))
    best_aic = float('inf')
    best_order = None
    for order in pdq:
        try:
            model = ARIMA(series, order=order)
            model_fit = model.fit()
            if model_fit.aic < best_aic:
                best_aic = model_fit.aic
                best_order = order
        except:
            continue
    print(f"Best ARIMA order for {stock_name}: {best_order} (AIC: {best_aic:.2f})")
    return best_order

# Select ARIMA order for each stock
best_orders = {}
for ticker in tickers:
    best_orders[ticker] = select_arima_order(returns[ticker], ticker)